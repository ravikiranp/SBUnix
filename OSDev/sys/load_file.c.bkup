#include<function.h>
#include<structs.h>
#include<defs.h>
#include"elf_header.h"
extern void map_user_page_virtual(uint64_t *, uint64_t, uint64_t, uint16_t, int);
extern int parse_taskid;
extern struct parse_info * file; 
extern struct load_info * load_file_list;
extern uint64_t * virtual_physfree;

void load_file(uint64_t * src, uint64_t offset, uint64_t size, uint64_t * dest, uint64_t * entry_point) {
//void load_file() {
	 uint64_t free = (uint64_t)get_free_page();
	 //uint64_t loc_offset;
	 uint16_t i;
	 int page_size = (int) size;
	 uint16_t no_of_pages = 0;
         //print_out("mapping %p to %x     ",dest,free);
	 entry_point = (uint64_t *)0x4000b0;
	 //uint16_t task_id = create_task((uint64_t)entry_point,0); 

	 i = parse_taskid;
	 task[i].task_id = parse_taskid;
         task[i].waitid = 20;
         task[i].ref_count = 0;
         task[i].task_parent_id = 0;
         task[i].task_rip = (uint64_t)entry_point;

         uint64_t * stack_free = stack_malloc(i,2048);
         task[i].task_kstack = (uint64_t *)stack_free;
         stack_free = stack_malloc(i,2048);
         task[i].task_ustack = (uint64_t *)stack_free;

         task[i].task_kstack_top = (uint64_t)&(task[i].task_kstack[255]);
         task[i].task_ustack_top = (uint64_t)&(task[i].task_ustack[255]);

         task[i].kmalloc_page_ptr = (uint64_t *)0xffffffff80d00000;
         task[i].kmalloc_free_ptr = (uint64_t *)0xffffffff80d00000;
         task[i].state = 4;
         task[i].first_switch = 1;

         (task[i].task_kstack[255])    = 0x23;
         (task[i].task_kstack[254])    = task[i].task_ustack_top;
         (task[i].task_kstack[253])    = 0x200;
         (task[i].task_kstack[252])    = 0x1b;
         (task[i].task_kstack[251])    = (uint64_t)entry_point;

         task[i].task_kstack_top = (uint64_t)&(task[i].task_kstack[251]);

	 uint64_t phys_base = (uint64_t)0xffffffff80000000;
         uint64_t * addr = get_free_page_for_tasks();
         task[i].cr3 = (uint64_t *)addr;
         uint64_t temp = (uint64_t)0xffffffff80000000;
         temp = temp | (uint64_t)addr;
         uint64_t * vir_addr = (uint64_t *)temp;
         task[i].virtual_cr3 = (uint64_t *)vir_addr;
         map_user_page_virtual((uint64_t *)vir_addr,(uint64_t)phys_base,(uint64_t)0x000000,2816,7);
         addr = get_free_page_for_tasks();
         map_user_page_virtual((uint64_t *)vir_addr,(uint64_t)0x000000,(uint64_t)addr,1,7);
	 
	while(page_size > 0) {
		no_of_pages += 1;
		page_size -= 4096;
	 }

         map_user_page_virtual((uint64_t *)vir_addr,(uint64_t)dest,free,no_of_pages,7);	

	 __asm__ volatile("movq %0,%%cr3;"
			:
			:"b"((uint64_t *)task[i].cr3)
			);

	//file = parse_elf("bin/hello");
	//load_file_list = file->load_list;	

	 char * copy_from = (char *)(file->file_start_ptr + load_file_list->file_offset);
	 char * copy_to = (char *) load_file_list->v_addr;
	 uint64_t loc_offset = 0;

	 //print_out(" the contents of %d no of pages starting from %x will be copied to %x, the file exec point is %x and the task id of this task will be %d",no_of_pages,copy_from,copy_to,entry_point,i);

	 for(loc_offset = 0;loc_offset<load_file_list->file_seg_size;loc_offset++) {
		*copy_to = *copy_from;
		 copy_from+=1;
		 copy_to+=1;
	}
	uint64_t phy = (uint64_t)virtual_physfree;	
	phy = phy & (uint64_t)0x000000000fffffff;
	
	print_out("  %x  ",phy);

	__asm__ volatile("mov %0, %%cr3"
		: :"b"((uint64_t *)phy)
		);
	
	total_tasks -= 1;
}	
